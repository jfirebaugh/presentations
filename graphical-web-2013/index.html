<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">

  <title>iD: A Pure D3 Application</title>

  <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
  <meta name="author" content="Hakim El Hattab">

  <meta name="apple-mobile-web-app-capable" content="yes"/>
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="css/reveal.min.css">
  <link rel="stylesheet" href="css/theme/simple.css" id="theme">
  <link rel="stylesheet" href="css/custom.css">

  <!-- For syntax highlighting -->
  <link rel="stylesheet" href="lib/css/zenburn.css">

  <!-- If the query includes 'print-pdf', use the PDF print sheet -->
  <script>
    document.write('<link rel="stylesheet" href="css/print/' + ( window.location.search.match(/print-pdf/gi) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">');
  </script>

  <!--[if lt IE 9]>
  <script src="lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
<div class="reveal">
<div class="slides">

<section>
  <header>
    <h1 class="iD">iD</h1>
    <h3>A Pure D3 Application</h3>
  </header>
  <author>John Firebaugh</author>
  <ul class="affiliations">
    <li>(m) MapBox</li>
    <li>(t) jfire</li>
    <li>(h) jfirebaugh</li>
  </ul>
</section>

<section>
  <h2>Typical Web Application</h2>
</section>

<section>
  <img style="width: 50%" src="img/jquery.png">
</section>

<section>
  <img style="width: 50%" src="img/backbone.png">
</section>

<section>
  <h2 class="moustache" style="font-size: 1000%;">}</h2>
</section>

<section>
  <h2>Hipster Web Application</h2>
</section>

<section>
  <img style="width: 50%" src="img/zepto.png">
</section>

<section>
  <img src="img/ember.png">
</section>

<section>
  <img src="img/handlebars.png">
</section>

<section>
  <h2 class="iD">iD</h2>
</section>

<section>
  <img style="z-index: -1; position: absolute; top: 5%; left: 10%; width: 50%;" src="img/zepto.png">
  <img style="z-index: -1; position: absolute; top: 35%; left: 35%;" src="img/ember.png">
  <img style="z-index: -1; position: absolute; top: 30%; left: 0%; width: 25%;" src="img/handlebars.png">
  <img style="z-index: -1; position: absolute; top: 30%; left: 65%;" src="img/jquery.png">
  <img style="z-index: -1; position: absolute; top: 75%; left: 20%; width: 55%;" src="img/backbone.png">
  <h2 class="moustache" style="z-index: -1; position: absolute; top: 50%; left: 75%; font-size: 600%;">}</h2>
  <h2 style="font-size: 2000%; font-weight: bold; opacity: 0.8; color: red;">⃠</h2>
</section>

<section>
  <h2 style="font-size: 1000%">D3</h2>
</section>

<section>
  <iframe class="stretch" src="http://openstreetmap.us/iD/master/"></iframe>
</section>

<section>
  <table>
    <tr><td class="numeric">11,728</td><td>sloc</td></tr>
    <tr><td class="numeric">6,379</td><td>sloc tests</td></tr>
    <tr><td class="numeric">10,000</td><td>users</td></tr>
    <tr><td class="numeric">1,728</td><td>closed issues</td></tr>
    <tr><td class="numeric">41</td><td>translations</td></tr>
    <tr><td class="numeric">3</td><td>lead developers</td></tr>
    <tr><td class="numeric">1</td><td>designer</td></tr>
  </table>
</section>

<section>
  <table>
    <tr><th></th><th>jQuery</th><th>D3</th></tr>
    <tr><th>Ajax</th>         <td class="check">✓</td><td class="check">✓</td></tr>
    <tr><th>Attributes</th>   <td class="check">✓</td><td class="check">✓</td></tr>
    <tr><th>CSS</th>          <td class="check">✓</td><td class="check">✓</td></tr>
    <tr><th>Data</th>         <td class="check">✓</td><td class="check">✓</td></tr>
    <tr><th>Dimensions</th>   <td class="check">✓</td><td class="ex">✗</td></tr>
    <tr><th>Effects</th>      <td class="check">✓</td><td class="check">✓</td></tr>
    <tr><th>Events</th>       <td class="check">✓</td><td class="check">✓</td></tr>
    <tr><th>Manipulation</th> <td class="check">✓</td><td class="check">✓</td></tr>
    <tr><th>Selectors</th>    <td class="check">✓</td><td class="check">✓</td></tr>
    <tr><th>Traversal</th>    <td class="check">✓</td><td class="check">✓</td></tr>
    <tr class="fragment"><th>Data Binding</th><td class="ex">✗</td><td class="check">✓</td></tr>
  </table>

  <aside class="notes">
    Traditionally, D3 is thought of as a tool for building data-driven visualizations. But in fact, the core of D3 is
    highly general purpose, and is perfectly suitable for the same problem domains as jQuery -- namely just about any
    kind of website or web application other than a completely static page. In fact, viewed in a certain light, jQuery
    and D3 are so similar that I wound up building practically the world's most boring feature comparison matrix.

    Yes, there's one feature missing from D3 in this matrix -- I'll come back to that later.

    But now that I've build an app entirely with D3 and entirely without jQuery, I strongly prefer the former. Why is
    that? Well, actually, I left out a row from the matrix. What D3 has that jQuery doesn't is data binding.
  </aside>
</section>

<section>
  <h2>Declarative > Imperative</h2>

  <aside class="notes">
    One reason is that D3 allows me to write code in a more declarative way than jQuery, making the relationship between
    my data and its DOM representation explicit and the specific sequence of DOM operations implicit.

    Writing declaratively is an advantage in this domain because the data-DOM relationship is important, and the gory
    details of how to build and maintain that relationship are typically not. Promoting the important and demoting the
    unimportant makes my code clearer, more concise, and easier to understand and reason about.
  </aside>
</section>

<section>
  <h2 class="jQuery">jQuery</h2>
  <pre><code data-trim>
var li = $('li');
if (layerSelected(li.data('layer-id'))) {
    li.addClass('selected');
} else {
    li.removeClass('selected');
}
  </code></pre>
</section>

<section>
  <h2 class="jQuery">jQuery</h2>
  <pre><code data-trim>
$('.layers li').each(function() {
    var li = $(this);
    if (layerSelected(li.data('layer-id'))) {
        li.addClass('selected');
    } else {
        li.removeClass('selected');
    }
});
  </code></pre>
</section>

<section>
  <h2>D3</h2>
  <pre><code data-trim>
items.classed('selected', function(d) { return d.selected; });
  </code></pre>
</section>

<section>
  <span style="position: relative; right: 0;">Raw DOM APIs</span>
  <span style="position: relative; right: 0;">jQuery</span>
  <span style="position: relative; right: 0;">D3</span>

  <span class="fragment fade-in">
    <span style="position: relative; right: 0;" class="fragment fade-out">?</span>
  </span>

  <span class="fragment fade-in">
    <span style="position: relative; right: 0;" class="fragment fade-out">XSL</span>
  </span>

  <span class="fragment fade-in">
    <span style="position: relative; right: 0;" class="fragment fade-out">Khan</span>
  </span>

  <div style="width: 960px; border-top: 2px solid black;">
    <span style="float: left;">Imperative</span>
    <span style="float: right;">Declarative</span>
  </div>

  <aside class="notes">
    If you start reading about declarative languages, you'll -- not surprisingly -- find a lot of nerds arguing
    about definitions. What makes one language or framework "imperative" and another one "declarative"? There's no hard
    and fast answer. It's probably more productive to look at it as a spectrum.

    So plotting tools for building and maintaining a relationship between data and a representation of that data on a
    web page on this spectrum, we'd say that Raw DOM APIs are about the most imperative way we could do it; jQuery is
    a bit more declarative, in that it introduces a concept of a collection of DOM elements that can be manipulated as
    a group; and a tool with data-binding like D3 is more declarative still.

    It's interesting to think about what's to the right of D3 on this continuum. I asked on Twitter. Some of the
    suggestions were XSL, frameworks like Angular and Ember that support two-way data binding, which I think is a really
    good answer, and Genghis Khan.
  </aside>
</section>

<section>
  <h2>MV*</h2>
</section>

<section>
  <img src="img/node-way-relation.png">

  <aside class="notes">
    The OSM data model consists of nodes, ways, and relations, and key-value tags on each of those data types.
  </aside>
</section>

<section>
  <img src="img/graph-1.png">

  <aside class="notes">
    Though it exposes slightly different abstractions in the interface, iD implements the OSM data model internally. It
    has Node, Way, and Relation classes (which we call entities generically), as well as Graph class that is a container
    for a set of entities and their relationships to each other.
  </aside>
</section>

<section>
  <img src="img/graph-2.png">

  <aside class="notes">
    Finally, iD has a class that’s used to store the history of an editing session and to implement undo/redo.

    Now, the traditional way to implement an edit history is via mutation. For each editing action you write a bit of
    code that knows exactly how to change the graph in order to do the action, and a bit of code that knows how to
    change the graph in order to undo it. Both of those bits of code live in a command object, and the history is a
    stack of commands that have been performed.

    This is <em>not</em> how iD does it.
  </aside>
</section>

<section>
  <img src="img/graph-3.png">

  <aside class="notes">
    In iD, entities and graphs are immutable. Entity and Graph objects do not change. Instead, editing actions produce
    <em>new versions</em> of entities, and new graphs. The history is a sequence of graphs. Here, for example, the user
    has edited the tags of a relation, producing a new version of that relation and a new graph. Now, here’s the clever
    part: the other entity references in that second graph are referencing the same objects as in the first graph.
  </aside>
</section>

<section>
  <img src="img/graph-4.png">

  <aside class="notes">
  </aside>
</section>

<section>
  <img src="img/graph-5.png">

  <aside class="notes">
  </aside>
</section>

<section>
  <h2>Templates</h2>
  <h2 class="moustache" style="font-size: 1000%;">}</h2>
  <img src="img/handlebars.png">
</section>

<section>
  <h2>Templates</h2>

  <aside class="notes">
    * Start with simple static, server-rendered page.
    * Add some client-side jQuery interactivity.
    * Want to do something more sophisticated.
    * Introduce backbone, rewrite entire page as a client-side
      template.
    * Want to do sophisticated dynamic DOM manipulation,
      transitions, etc.
    * Or: want to extract a component.
    * Wind up building pieces programmatically anyway.
  </aside>
</section>

<section>
  <h2>Continuity of Expressiveness</h2>

  <aside class="notes">

  </aside>
</section>

<section>
  <h2>Master the Data-Join</h2>

  <aside class="notes">
    The data-join is a way of declaratively specifying the relationship between your data and the DOM. Maintaining that
    relationship necessarily involves updating the DOM in response to changes in the data.

    Different frameworks take different approaches to solving this problem.

    Backbone leaves it up to you to rerender your view in response to relevant change events from the model. In
    practice, this means either rerendering the entire template, or introducing what is effectively a secondary
    parallel rendering path, where specific portions of the DOM are updated in response to fine-grained change events.

    Ember and angular recognized that this is an antipattern, and provide a template implementation that's smart enough
    to automatically update in response to changes in the model -- providing you work within the constraints of the
    model and observer framework that is provided.
  </aside>
</section>

<section>
  <h2>Master the Data-Join</h2>

  <aside class="notes">
    For iD, D3 data joins provide just the right combination: flexible enough to support a completely custom
    data model and mutation strategy, powerful enough to support efficient, targeted updates to the DOM.
  </aside>
</section>

<section>
  <h2>Work-minimization Techniques</h2>
  <ul>
    <li>Declare static properties on the enter selection
    <li>Declare dynamic properties on the update selection
    <li>Batch updates: no individual "instance changed" events
    <li>Filter the selection to the entities which actually changed
  </ul>
  <aside class="notes">
    <dl>
      <dt>Declare static structure on the enter selection</dt>
      <dd>
        If something never changes, don't waste time setting it on every render. This is usually things like constant
        CSS class values, input type attributes.

        It's also often the overall structure of the DOM. Set it up once by chaining off the enter selection.
      </dd>

      <dt>Declare dynamic properties on the update selection</dt>
      <dd>
        Things that change go in the update selection. Take advantage of the fact that the enter selection is
        automatically merged into the update selection when you append.
      </dd>

      <dt>Batch updates: no individual "instance changed" events</dt>
      <dd>
        As a consequence of the iD data model, where mutations are expressed as action functions that take as input a
        graph and return a new, modified graph, it doesn't have change events on the level of individual entities.
        There's one change event, indicating that an action took place and the current graph has changed.

        This is actually a good thing, because it means updates are batched. For instance, when you move the map feature
        that represents a rectangular building, you produce new versions of at least five entities: the four corner
        nodes, and the way containing those nodes that represents the building. It would be incredibly inefficient to
        trigger five different change events and update the SVG in five individual steps.
      </dd>

      <dt>Filter the selection to the entities which actually changed</dt>
      <dd>
        So, instead, iD has a single "graph changed" event. However, the history representation is sophisticated enough
        that it's possible to calculate the difference between two versions of the graph. We use that to update the
        minimal set of DOM elements by filtering the selection down to the subset that actually changed.
      </dd>
    </dl>
  </aside>
</section>

<section>
  <h2>Problem: D3 is too big!</h2>
  <iframe src="treemap.html" width="960px" height="500px"></iframe>
</section>

<section>
  <h2>Solution: SMASH!</h2>
  <img src="img/geohulk.jpg">

  <p>mbostock/smash</p>
</section>

<section>
  <pre><code data-trim>
D3_FILES = \
	node_modules/d3/src/start.js \
	node_modules/d3/src/arrays/index.js \
	node_modules/d3/src/behavior/behavior.js \
	node_modules/d3/src/behavior/zoom.js \
	node_modules/d3/src/core/index.js \
	[...]
	node_modules/d3/src/end.js

js/lib/d3.v3.js: $(D3_FILES)
	node_modules/.bin/smash $(D3_FILES) > $@
  </code></pre>
</section>
                    
<section>
  <h2>Problem: D3 is too small!</h2>
  <table class="fragment">
    <tr><th></th><th>jQuery</th><th>D3</th></tr>
    <tr><th>Dimensions</th><td class="check">✓</td><td class="ex">✗</td></tr>
  </table>
</section>

<section>
  <h2>Solution: Write Plugins!</h2>
  <pre><code data-trim>
d3.selection.prototype.dimensions = function (dimensions) {
    if (!arguments.length) {
        var node = this.node();
        return [node.offsetWidth,
                node.offsetHeight];
    }
    return this.attr({width: dimensions[0], height: dimensions[1]});
};
  </code></pre>
</section>

<section>
  <h2>More Plugins!</h2>
  <ul>
    <li>d3/d3-plugins
    <li>shawnbot/d3-bootstrap
  </ul>
</section>

</div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.min.js"></script>

<script>
  // Full list of configuration options available here:
  // https://github.com/hakimel/reveal.js#configuration
  Reveal.initialize({
      controls: false,
      progress: true,
      history: true,
      center: true,

      theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
      transition: Reveal.getQueryHash().transition || 'fade', // default/cube/page/concave/zoom/linear/fade/none

      // Optional libraries used to extend on reveal.js
      dependencies: [
      { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
      { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
      { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
      ]
  });
</script>
</body>
</html>
